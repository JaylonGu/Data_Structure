/*
假设五子棋的棋盘是N * N的（正整数N<20），黑子用*表示，白子用#表示，空位置用. 表示。
现给你一个棋局，请判断黑子是否获胜，如获胜，显示Win，并给出获胜排列的最左边那列的最上方那颗棋子的坐标。（棋盘左上角坐标是 (0, 0) ，右下角坐标是 (N-1, N-1)）
如果未获胜，则显示“Not yet”。
注意：

不考虑白子是否获胜以及棋子个数与黑子是否匹配，只考虑黑子排列。
为简化计算，不用考虑“活四”、“四三连”、“长连”、“三三连”等获胜或禁手条件，只判断黑子有5个（或更多）排成一条直线，包括横线、竖线或斜线为胜利条件。
输入保证最多只出现一处黑子胜利的排列，不需要考虑有多处排列时如何判断最左位置。
输入格式:
第一行是正整数N（N<20），接下来是表示棋盘排列的N行字符，每行有N个*或#或.字符。

输出格式:
若黑子（用*表示）获胜，打印一行字符，依次是 Win X Y ，其中X Y是黑子获胜排列的最左边那列的最上方的一颗棋子的坐标，X表示横坐标，Y表示纵坐标。
若黑子未获胜，打印一行： Not yet 。

输入样例1:
6
.***..
..#...
..#...
......
....*.
.....*
输出样例1:
Not yet
输入样例2:
7
..#....
..#....
..#..*.
..#.*..
..#*...
..*..##
.*.****
输出样例2:
Win 1 6
*/

#include <iostream>
using namespace std;

char board[20][20];

int main(){
    int N;
    cin>>N;
    for(int i=0;i<N;++i){
        for(int j=0;j<N;++j){
            cin>>board[i][j];
        }
    }

    return 0;
}